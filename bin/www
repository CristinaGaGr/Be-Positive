#!/usr/bin/env node
var express = require("express")
const http = require('http');
let app = require('../app');
const Chat = require('../models/chat');
const User = require('../models/user');
var rooms = [];

// catch 404 and render a not-found.hbs template
app.use((req, res, next) => {
  res.status(404);
  res.render('not-found');
});

app.use((err, req, res, next) => {
  // always log the error
  console.error('ERROR', req.method, req.path, err);

  // only render if the error ocurred before sending the response
  if (!res.headersSent) {
    res.status(500);
    res.render('error');
  }
});

let server = http.createServer(app);
const io = require('socket.io').listen(server)


server.listen(process.env.PORT, () => {
  console.log(`Listening on http://localhost:${process.env.PORT}`);
});
User.find({})
  .then(response => {
    response.forEach(element => {
      rooms.push(element.name)
    });
  })

io.on('connection', function (socket) {
  //usernames which are currently connected to the chat
  var usernames = {};
  console.log(usernames)
  // rooms which are currently available in chat

  io.sockets.on('connection', function (socket) {

    // when the client emits 'adduser', this listens and executes
    socket.on('adduser', function (username) {
      // store the username in the socket session for this client
      socket.username = username;
      // store the room name in the socket session for this client
      socket.room = 'room1';
      // add the client's username to the global list
      usernames[username] = username;
      // send client to room 1
      socket.join('room1');
      // echo to client they've connected
      socket.emit('updatechat', 'SERVER', 'you have connected to room1');
      // echo to room 1 that a person has connected to their room
      socket.broadcast.to('room1').emit('updatechat', 'SERVER', username + ' has connected to this room');
      socket.emit('updaterooms', rooms, 'room1');
    });

    // when the client emits 'sendchat', this listens and executes
    socket.on('sendchat', function (data) {
      // we tell the client to execute 'updatechat' with 2 parameters
      io.sockets.in(socket.room).emit('updatechat', socket.username, data);
    });

    socket.on('switchRoom', function (newroom) {
      // leave the current room (stored in session)
      socket.leave(socket.room);
      // join new room, received as function parameter
      socket.join(newroom);
      socket.emit('updatechat', 'SERVER', 'you have connected to ' + newroom);
      // sent message to OLD room
      socket.broadcast.to(socket.room).emit('updatechat', 'SERVER', socket.username + ' has left this room');
      // update socket session room title
      socket.room = newroom;
      socket.broadcast.to(newroom).emit('updatechat', 'SERVER', socket.username + ' has joined this room');
      socket.emit('updaterooms', rooms, newroom);
    });

    // when the user disconnects.. perform this
    socket.on('disconnect', function () {
      // remove the username from global usernames list
      delete usernames[socket.username];
      // update list of users in chat, client-side
      io.sockets.emit('updateusers', usernames);
      // echo globally that this client has left
      socket.broadcast.emit('updatechat', 'SERVER', socket.username + ' has disconnected');
      socket.leave(socket.room);
    });

  });
});









//https://socket.io/docs/
//recives message
//generate classroms

// io.on('connection', function (socket) {
//   let rooms = {}
//   socket.on('join', function (data) {
//     socket.join(data.room); // We are using room of socket io

//     rooms.push()
//     io.sockets.in(data.room).emit('new_msg', { msg: 'hello' })
//   })
//   socket.on("joaquimtotest", function (msg) {
//     console.log(msg)
//   })
// })
// console.log("message from:", msg.sender, " to:", msg.reciver, "content:", msg.message);


// sends message to users
// io.on('connection', function (socket) {
//   socket.on('hola', function (msg) {
//     io.emit('hola', msg);
//   });
// });

























server.on('error', error => {
  if (error.syscall !== 'listen') { throw error }

  // handle specific listen errors with friendly messages
  switch (error.code) {
    case 'EACCES':
      console.error(`Port ${process.env.PORT} requires elevated privileges`);
      process.exit(1);
      break;
    case 'EADDRINUSE':
      console.error(`Port ${process.env.PORT} is already in use`);
      process.exit(1);
      break;
    default:
      throw error;
  }
});

